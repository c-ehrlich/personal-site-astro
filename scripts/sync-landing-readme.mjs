import { mkdir, readFile, writeFile } from "node:fs/promises";
import { dirname, resolve } from "node:path";

const README_URL =
  process.env.LANDING_README_URL ??
  "https://raw.githubusercontent.com/c-ehrlich/c-ehrlich/main/README.md";
const OUTPUT_PATH = resolve("src/content/generated/landing-readme.md");
const SECTION_START = "<!-- LANDING:START -->";
const SECTION_END = "<!-- LANDING:END -->";

const normalizeNewlines = (value) => value.replaceAll("\r\n", "\n");

const extractSection = (markdown) => {
  const startIndex = markdown.indexOf(SECTION_START);
  const endIndex = markdown.indexOf(SECTION_END);

  if (startIndex === -1 || endIndex === -1 || endIndex <= startIndex) {
    return markdown;
  }

  return markdown
    .slice(startIndex + SECTION_START.length, endIndex)
    .trim();
};

const toGeneratedMarkdown = (markdown) =>
  [
    "<!-- This file is generated by scripts/sync-landing-readme.mjs. -->",
    "",
    markdown.trim(),
    "",
  ].join("\n");

const readFileIfExists = async (filePath) => {
  try {
    return await readFile(filePath, "utf8");
  } catch (error) {
    if (error.code === "ENOENT") {
      return null;
    }

    throw error;
  }
};

const fetchReadme = async () => {
  // raw.githubusercontent.com is CDN cached; force revalidation on each sync.
  const readmeUrl = new URL(README_URL);
  readmeUrl.searchParams.set("cb", String(Date.now()));

  const response = await fetch(readmeUrl, {
    cache: "no-store",
    headers: {
      "User-Agent": "personal-site-astro-readme-sync",
      Accept: "text/plain",
      "Cache-Control": "no-cache",
      Pragma: "no-cache",
    },
  });

  if (!response.ok) {
    throw new Error(`README fetch failed (${response.status} ${response.statusText})`);
  }

  return response.text();
};

const main = async () => {
  try {
    const markdown = normalizeNewlines(await fetchReadme());
    const section = extractSection(markdown);
    const output = toGeneratedMarkdown(section);

    await mkdir(dirname(OUTPUT_PATH), { recursive: true });
    const existing = await readFileIfExists(OUTPUT_PATH);

    if (existing === output) {
      console.log("landing-readme: unchanged");
      return;
    }

    await writeFile(OUTPUT_PATH, output, "utf8");
    console.log(`landing-readme: wrote ${OUTPUT_PATH}`);
  } catch (error) {
    const existing = await readFileIfExists(OUTPUT_PATH);

    if (existing) {
      console.warn(
        `landing-readme: fetch failed (${error.message}); using existing generated file`,
      );
      return;
    }

    throw error;
  }
};

main().catch((error) => {
  console.error(`landing-readme: ${error.message}`);
  process.exitCode = 1;
});
